<link rel="import" href="../base/request.html">

<script>

    /**
     *
     */
    class RequestElectron extends RequestBase {

        /**
         *
         */
        constructor() {
            super();
            this.electronRemote = require( 'electron' ).remote;
            this.protocol = this.electronRemote.require( 'electron' ).protocol;
            let req = this.electronRemote.require( 'request' );
            this.cookies = req.jar();
            this.request = req.defaults( { jar: this.cookies } ); // cookies should be enabled
            this.agentHTTP = this.electronRemote.require( 'http' ).globalAgent;
            this.agentHTTPS = this.electronRemote.require( 'https' ).globalAgent;
            this.crypto = this.electronRemote.require( 'crypto' );
            this.browser = this.electronRemote.BrowserWindow;
            this.reconnectDelay = 1000; // average value Â± 50% random distribution
            this.reconnectErrors = [
                'ETIMEDOUT',
                'ESOCKETTIMEDOUT',
                'ECONNRESET',
                'ECONNREFUSED',
                //'EHOSTUNREACH',
                //'ENOTFOUND',
                //'EAI_AGAIN',
            ];
            this.ipChain = this._randIP( 3 );
            this.protocolTable = [];

            //
            document.addEventListener( EventListener.onSettingsChanged, this.onSettingsChanged.bind( this ) );
        }

        /**
         *
         */
        onSettingsChanged( e ) {
            this.agentHTTP.maxSockets = e.detail.socketConnections.value;
            this.agentHTTPS.maxSockets = e.detail.socketConnections.value;
            // set google data saver for electron browser window requests (does not apply to NPM request module).
            let proxy = {};
            if( e.detail.useGoogleDataSaver.value ) {
                proxy['proxyRules'] = 'http=http://proxy.googlezip.net:80';
                //proxy['proxyBypassRules'] = [ 'https://*' ];
            }
            this.electronRemote.session.defaultSession.setProxy( proxy, () => {
                //console.log( 'SET PROXY:', proxy );
            });
        }

        /**
         *
         */
        registerProtocol( scheme, callback ) {
            this.protocolTable[scheme + ':'] = callback;
            // register callback for electron process (when callback becomes unavailable by e.g. by reloading page, the previous registered handler must be removed)
            this.protocol.isProtocolHandled( scheme, ( error ) => {
                if( error ) {
                    this.protocol.unregisterProtocol( scheme, ( e ) => {
                        this.protocol.registerBufferProtocol( scheme, callback );
                    } );
                } else {
                    this.protocol.registerBufferProtocol( scheme, callback );
                }
            } );
        }

        /**
         * Since the request module does not support custom protocol handler we need to track and take care of them ourselves
         */
        _handleProtocol( options, callback ) {
            let protocol = ( new URL( options.url ) ).protocol;
            if( !this.protocolTable[protocol] ) {
                return false;
            }
            let request = {
                url: options.url, //url String
                // TODO: check for referer in options.headers
                referrer: options.url, //referrer String
                //method: '', //method String
                //uploadData: [], //uploadData UploadData[]
            }
            this.protocolTable[protocol]( request, ( data ) => {
                if( !data || !data.mimeType || !data.data ) {
                    callback( new Error( `Failed to get content from "${ request.url }"` ), undefined, undefined );
                    return;
                }
                let response = {
                    statusCode: 200,
                    headers: {
                        'Content-Type': data.mimeType
                    }
                };
                callback( null, response, data.data );
            } );
            return true;
        }

        /**
         * Electron specific implementation of the fetch method to make HTTP requests.
         */
        fetch( options, callback, retries ) {
            options = this._prepareHeaders( options );
            if( this._handleProtocol( options, callback ) ) {
                return;
            }
            retries = ( retries !== undefined ? retries : 3 );
            if( retries < 0 ) {
                callback( new Error( 'The url "' + ( options.url ? options.url : options ) + '" could not be reached' ), undefined, undefined );
                return;
            }
            this.request( options, ( error, response, content ) => {
                if( error && this.reconnectErrors.indexOf( error.code ) > -1 ) {
                    setTimeout( () => {
                        this.fetch( options, callback, retries-1 );
                    }, 0.5 * ( Math.random() * this.reconnectDelay + this.reconnectDelay ) );
                } else {
                    callback( error, response, content );
                }
            } );
        }
        /**
         * Browser intern fetch API
         */
/*
        fetchCR( options, retries ) {
            fetch( options.url, options )
            .then( ( response ) => {
                console.log( 'FETCH', response );
                //console.log(response.headers.get('Content-Type'));
                //console.log(response.headers.get('Date'));
                //console.log(response.status);
                //console.log(response.statusText);
                //console.log(response.type);
                //console.log(response.url);
                // response.ok // true, false
                // response.status
                // response.json().then(...)
                response.text()
                .then( ( data ) => {
                    callback( null, response, data );
                } )
                .catch( ( error ) => {
                    callback( error, undefined, undefined );
                } );
            } )
            .catch( ( error ) => {
                console.log( 'FETCH', error );
                callback( error, undefined, undefined );
            } );
        }
*/
        /**
         *
         */
        fetchUI( options, script, callback ) {
            let win = new this.browser( {
                show: false,
                webPreferences: {
                    nodeIntegration: false,
                    webSecurity: true
                }
            } );

            let preventCallback = false;

            let abortAction = setTimeout( () => {
                //console.log( '  TIMEOUT', options.url );
                this._fetchUICleanup( win, abortAction );
                if( !preventCallback ) {
                    callback( new Error( `Failed to load '${options.url}'` ), undefined, undefined );
                }
            }, 10000 );
            
            win.webContents.session.webRequest.onBeforeRequest( { urls: ['http://*/mobi/js/chapter.js*'] }, ( details, callback ) => {
                callback( { redirectURL: 'cache://hakuneko/js/chapter.js' } );
            } );

            win.webContents.on( 'did-finish-load', ( e ) => {
                // ensure variables in this script does not appear in the page or other injected script
                let uVar = [
                    '_c13367', // 'code',
                    '_d8fd50', // 'message',
                    '_cb5e10', // 'error',
                    '_e9a23c', // 'meta',
                    '_d9904d', // 'cf',
                    '_b4a884', // 'result',
                ];
                let check = `
                    let ${uVar[0]} = document.querySelector( '.cf-error-code' );
                    ${uVar[0]} = ( ${uVar[0]} ? ${uVar[0]}.innerText : null );
                    let ${uVar[1]} = document.querySelector( 'h2[data-translate]' );
                    ${uVar[1]} = ( ${uVar[1]} && ${uVar[1]}.nextElementSibling ? ${uVar[1]}.nextElementSibling.innerText : null );
                    let ${uVar[2]} = ( ${uVar[0]} ? 'CF Error ' + ${uVar[0]} + ' => ' + ${uVar[1]} : null );

                    let ${uVar[3]} = document.querySelector( 'meta[http-equiv="refresh"][content*="="]' );
                    let ${uVar[4]} = document.querySelector( 'form#challenge-form' );

                    let ${uVar[5]} = {
                        error: ${uVar[0]},
                        redirect: ( ${uVar[3]} || ${uVar[4]} )
                    };
                    ${uVar[5]};
                `;
                //console.log( 'DOM-READY' );
                win.webContents.executeJavaScript( check, ( result ) => {
                    //console.log( '  REDIRECT', result.redirect );
                    if( !result.redirect ) {
                        if( result.error ) {
                            //console.log( '      CLOUDFLARE', result.error, options.url );
                            this._fetchUICleanup( win, abortAction );
                            callback( new Error( result.error ), undefined, undefined );
                        } else {
                            //console.log( '    INJECT', script );
                            preventCallback = true; // no other event shall execute the callback function anymore!
                            win.webContents.executeJavaScript( script, ( result ) => {
                                //console.log( '      RESULT', result, options.url );
                                this._fetchUICleanup( win, abortAction );
                                callback( null, undefined, result );
                            } );
                        }
                    }
                } );
            } );

            win.webContents.on( 'did-fail-load', ( event, errCode, errMessage, uri, isMain ) => {
                //console.log( '      ERROR', event, errCode, errMessage, uri, isMain, options.url );
                if( !preventCallback && errCode && errCode !== -3 && ( isMain || uri === options.url ) ) {
                    this._fetchUICleanup( win, abortAction );
                    callback( new Error( errMessage + ' ' + uri ), undefined, undefined );
                }
            } );
            
            let opts = {
                httpReferrer: options.url,
                userAgent: ( options.headers && options.headers['User-Agent'] ? options.headers['User-Agent'] : this.userAgent )
            };
            win.loadURL( options.url, opts );
        }

        /**
         * Close window and clear the given timeout function
         */
        _fetchUICleanup( browserWindow, timeout ) {
            try {
                if( timeout ) {
                    clearTimeout( timeout );
                }
                timeout = null;
                if( browserWindow ) {
                    browserWindow.close();
                }
                browserWindow = null;
            } catch( e ) {
                //
            }
        }

        /**
         * Generate content of 'Chrome-Proxy' header field for use with google data saver
         */
        _getDataSaverHeader() {
            let key = 'ac4500dd3b7579186c1b0620614fdb1f7d61f944';
            let ts = Math.floor( Date.now() / 1000 );
            let hash = this.crypto.createHash( 'md5' ).update( ts + key + ts ).digest( 'hex' );
            let rd = Math.floor( 9999 * Math.random() );
            return 'ps=' + [ ts, rd, rd, rd ].join( '-' ) + ', sid=' + hash + ', b=3239, p=132, c=linux';
        }

        /**
         * Generate random IPs ( 1 ~ amount )
         */
        _randIP( amount ) {
            amount = amount || 1;
            let result = [];
            let rd = ( min, max ) => {
                return Math.floor( Math.random() * ( max - min + 1 ) ) + min;
            };
            let count = rd( 1, amount );
            // us ip blocks: https://www.nirsoft.net/countryip/us.html
            let usBlocks = [3,4,6,7,8,9,11,12,15,16,17,18,19,20,21,22,26,28,29,30,33,34,38,44,48,55,56,73,214,215];
            for(let i=0; i<count; i++) {
                let ip = [ usBlocks[ rd( 0, usBlocks.length - 1 ) ], rd( 1, 255 ), rd( 1, 255 ), rd( 1, 255 ) ];
                result.push( ip.join( '.' ) );
            }
            return result;
        }

        /**
         * Modify the request options to use any configured proxy server (e.g. Google Data Saver).
         * Set options & headers for NPM request module (does not apply to electron browser window).
         */
        _prepareHeaders( options ) {
            try {
                if( typeof options === 'string' ) {
                    options = {
                        url: options
                    };
                }
                if( options['gzip'] === undefined ) {
                    options['gzip'] = true;
                }
                let uri = new URL( options.url );
                options['headers'] = ( options['headers'] ? options['headers'] : {} );
                options['headers']['User-Agent'] = options['headers']['User-Agent'] || this.userAgent;
                // it cannot hurt to pretend the request already passed through some other proxy servers ...
                /*
                Disabled, because rejected by MangaDex
                if( options['headers']['X-Forwarded-For'] === undefined ) {
                    options['headers']['X-Forwarded-For'] = this.ipChain.join( ',' );
                }
                */
               /*
                if( options['headers']['Forwarded'] === undefined ) {
                    options['headers']['Forwarded'] = this.ipChain.map( ip => 'for=' + ip ).join( ',' );
                }
                */
                // use google data saver proxy server
                if( uri.protocol === 'http:' && Engine.Settings.useGoogleDataSaver.value ) {
                    //
                    options['proxy'] = 'http://proxy.googlezip.net:80';
                    options['headers']['Chrome-Proxy'] = this._getDataSaverHeader();
                    options['gzip'] = true;
                }
            } catch( e ) {
                console.error( e );
            } finally {
                return options;
            }
        }

        /**
         * Provide headers for the electron main process that shall be modified before every BrowserWindow request is made.
         * DO NOT RENAME THIS METHOD!
         */
        getRequestHeaders( details ) {
            // calling this method from electron main by ipcRenderer evaluation, escaped characters in JSON strings will break
            // e.g. '{ "cookie" : "token=\"a23f2bc345\"; user=guest;" }' => '{ "cookie" : "token="a23f2bc345"; user=guest;" }'
            // as a result JSON parse will fail (happens rarely, e.g. when some advertisements use cookies with quotes)
            try {
                details = JSON.parse( details );
            } catch( e ) {
                console.log( details, e );
                return undefined;
            }
            let uri = new URL( details.url );
            details.requestHeaders['User-Agent'] = details.requestHeaders['User-Agent'] || this.userAgent;
            // it cannot hurt to pretend the request already passed through some other proxy servers ...
            /*
            Disabled, because rejected by MangaDex
            if( details.requestHeaders['X-Forwarded-For'] === undefined ) {
                details.requestHeaders['X-Forwarded-For'] = this.ipChain.join( ',' );
            }
            */
            if( details.requestHeaders['Forwarded'] === undefined ) {
                details.requestHeaders['Forwarded'] = this.ipChain.map( ip => 'for=' + ip ).join( ',' );
            }
            if( uri.protocol === 'http:' && Engine.Settings.useGoogleDataSaver.value ) {
                details.requestHeaders['Chrome-Proxy'] = this._getDataSaverHeader();
            }

            // some manga connectors (e.g. DynastyScans) require a referer of the same origin for embeded images (ticket #2, commit [758df9])
            // => overwrite the referer for each request directly made through the electron browser
            // BUT: some other connectors like mangago require to keep the original referer
            //details.requestHeaders['Referer'] = details.url;
            switch ( true ) {
                case ( uri.hostname.indexOf( 'mangapicgallery' ) > -1 ):
                    uri.hostname = 'www.mnggo.net';
                    details.requestHeaders['Referer'] = uri.href;
                    break;
                case ( uri.hostname.indexOf( 'senmanga' ) > -1 && uri.search.indexOf( 'token=' ) > -1 ):
                    // token in query string must match the PHP session id (both from request module)
                    details.requestHeaders['Cookie'] = this.cookies.getCookieString( uri );
                    break;
                default:
                    // NEVER overwrite the referer for cloudflare's DDoS protection to prevent infinite redirects!
                    if( !details.requestHeaders['Referer'] && !uri.pathname.endsWith( 'chk_jschl' ) ) {
                        details.requestHeaders['Referer'] = details.url;
                    }
                    break;
            }

            return details;
        }
    }

</script>